# Central Auth Service
This service is meant to handle authenticating access to the av-api services in AWS.

Each service that desires to connect to the will be issued an api token, this token is either good for user-based access, or system based access, or some combination of the two.

I'm thinking of a few use cases here: 
1. Service based access - we have some service that turns off all the displays at night, or needs to get current state for self-healing purposes 
1. User-based-access:
    1. A user logs in via CAS to control a specific room, and has scheduled based permission.
    1. A user is in the room and sees a code on the screen and inputs that code.
    1. A user is in the room and taps their ID card to a reader and wants to gain access via their app.
    1. A user is in the room and has set up bluetooth authentication
    1. A super user logs in via CAS and has extended privileges to a room (I can set routes on the switcher that aren't accessable to all users)
    1. A set of users want to use smee (insert other service here), but has varying levels of access.

##Schema

Each request to the auth server should include several pieces of information

```
{
"access-token" : "SomeLongString",
"user-information": {
    "id": "SomeString"
    "user-auth-type": "A string denoting the user access type - e.g. CAS, Code-based, system, etc. etc.",
    "user-id": "The user id"
    "resource-id": "The resource being accessed - e.g. the room name"
    "resource-type": "The resource type - e.g. room"
    "data": {
            "This is a generic interface, depending on the user-type"
        }
    }
}
```

The server will respond with information along the lines of 

```
{
    "user-id": "",
    "user-auth-type": "",
    "resource-id": "",
    "resource-type": ""
    "data":{}
    "allowed-roles": [
        {
            "role": "e.g. read"
            "scope": ""
        }
    ],
    "ttl": "Some duration of time to treat this response as valid for, should be some short time period, maybe 1 minute or so"
}
```

## Request  
- `access-token` is the API key issued to the service
- `user-auth-type` denotes how the user is authenticating, and will determine how to interpret the `data` field
- `user-id` the id of the user authenticating
- `resource-id` denotes the resource that is being accessed
- `resource-type` denotes the type of resource, room, events, etc. etc. 
- `data` is a field for use in authenticating the user - this may include the passkey the user input, etc. etc.

## Response
- `user-auth-type` denotes how the user is authenticating, and will determine how to interpret the `data` field
- `user-id` the id of the user authenticating
- `resource-id` denotes the resource that is being accessed
- `resource-type` denotes the type of resource, room, events, etc. etc. 
- `ttl` the amount of time to cache this allowed permission
- `allowed-roles` a list of roles to allow - e.g. read, write, delete, etc. with their associated scopes e.g. configuration, state, alerts, etc.

## A few examples:

The following steps will be pretty common:
1. Request comes in with user `Tom`, resource-type `room-state` and id `ITB-1101`
1. We assume that TOM was properly authenticated as the user via CAS/app usage/ etc. etc. at the front end 
1. We check what rooms/roles Tom has access to.

#### Role based
> auth-type 'CAS'

1. Tom always has read/write access to ITB-1101 room-state. We return allowed roles as scope `room` and roles `read/write`

#### Schedule based
> auth-type 'CAS'

1. Tom always has reade access to ITB-1101 room-state. But schedule based access to the room for write permissions. 
1. We make a call to the scheduling system to see if he's scheduled in the room currently. 
1. We return the read allowed role, and the write allowed role if he's scheduled.

#### Code based 
> auth-type 'code'

1. The data includes the code Tom input
1. We make a call to the pi (or whatever else) in the room to see what the code showing is, check if match. 
    1. Alternately data doesn't include the code, but includes like 'init' or something like that, we make a call to show the code and store it for the room. The next call will include the code. 
1. We generate and store a session token with some expiry date - we return the data in the data field. Subsequent requests use the 'token' auth type.

#### Token base
> auth-type 'token'

1. The data field includes a token previously generated by the service - we check to see if it has lapsed.
1. If no, update the lapse period with whatever the inactivity period we've set is. 

Do we have some sort of hard expiration here?

#### NFC Card based
> auth-type 'card'?

Two concurrent things happen here: 
1. From the user 
    1. the data field contains a callback address. a
    1. We check some list that contains the list of people who have tapped on that reader in the last X seconds/minutes
    1. If not there, we register a request, return 'wait' or something like that, else return the list of roles the user has in the space. 
1. From the card reader deal
    1. Get a 'user tapped' event containing the user info. 
    1. Check to see if that user has registered a request for that room. if yes, send response with roles/etc to callback. 
    1. If no add it to the list of taps in the last x seconds. 

#### Bluetooth 
- similar to NFC, but just check with pi to see if someone has connected. a


I think the schema covers all the bases. Thoughts? 
